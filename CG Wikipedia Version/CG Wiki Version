
 /*
   1. r_0 = b - A * x_0      
 */
 MatVecProduct(Rptr, Cptr, NNZ, x,Ap); // A * x_0
 
 vecSubtract(b, Ap, r_new); // r_0 = b - A * x_0
 
 /*
   2. p_0 = r_0
 */
 initVecP(p,r_new);  // p_0 = r_0
 
 int k = 0;
 double alpha_num = 0.0;
 double alpha_den = 0.0;
 double beta_num = 0.0;
 double beta_den = 0.0;
 double error = 0.0;
 while(k<4000)
 {
   /*
     3. alpha = (r^T * r)/(p^T * A * p);
   */
   alpha_num = dotProduct(r_new,r_new); // r^T * r
   std::cout<<"alpha_num = "<<alpha_num<<std::endl;
   
   MatVecProduct(Rptr, Cptr, NNZ, p,temp); // temp = A * p
   alpha_den = dotProduct(p,temp);//p^T * A * p
   std::cout<<"alpha_den = "<<alpha_den<<std::endl;
   
   scalar_alpha = alpha_num/alpha_den; // alpha = (r^T * r)/(p^T * A * p); 
   std::cout<<"alpha = "<<scalar_alpha<<std::endl;
   
   /*
     4. x_k+1 = x_k + alpha * p_k
   */
   update_x(x,p,scalar_alpha);
   
   /*
     5. r_k+1 = r_k - alpha * A * p_k
   */
   update_prev_residue(r_new,r_prev);
   update_r(r_new,temp,scalar_alpha);
   
   error = L2Norm(r_new);
   std::cout<<"**********iteration: "<<k<<"   Error: "<<error<<std::endl;
   
   /*if(error < tol)   
   {
     break;
   }*/
      
   /*
     6. beta = (r_new^T * r_new^T)/(r_prev^T * r_prev^T)
   */
   
   beta_num = dotProduct(r_new,r_new); // (r_new^T * r_new^T)
   std::cout<<"beta_num = "<<beta_num<<std::endl;
   beta_den = dotProduct(r_prev,r_prev); // (r_prev^T * r_prev^T)
   std::cout<<"beta_den = "<<beta_den<<std::endl;
   scalar_beta = beta_num/beta_den; //beta = (r_new^T * r_new^T)/(r_prev^T * r_prev^T)
   std::cout<<"beta = "<<scalar_beta<<std::endl;
   
   update_p(p,r_new,scalar_beta);
   for(int i = 0; i < 10; i++)
   {
    std::cout<<" "<<x[i]<<std::endl;
   }
   
   resetTemp(temp);
   k = k+1;
 }

 
 */
  
